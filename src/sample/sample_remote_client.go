// Remote clients would be generated by decorating the 'application' interface with a go generate statement; i.e.
//
// //go:generate goremote -o ../somedir/sample_client_remote.go . MyService
//
// type MyService interface {
// ...
package sample

import (
	"encoding/json"

	goremote "../"
)

type remoteClient struct {
	Transport goremote.Transport
}

func NewRemoteClient(transport goremote.Transport) *remoteClient {
	return &remoteClient{
		Transport: transport,
	}
}

func (r *remoteClient) SampleMethod(sampleRequest SampleRequest) (SampleResponse, error) {

	body, err := json.Marshal(sampleRequest)
	if err != nil {
		return SampleResponse{}, err
	}

	reply, err := r.Transport.Send("samplemethod", body)
	if err != nil {
		return SampleResponse{}, err
	}

	if err {
		// poss. deserialize reply into SampleResponse
		return SampleResponse{}, err
	} else {
		var sampleResponse SampleResponse
		err = json.Unmarshal(reply, sampleResponse)
		if err != nil {
			return SampleResponse{}, err
		}
		return sampleResponse
	}

	return SampleResponse{}, nil
}

// and these would be typically be defined by the application
type SampleRequest struct {
}

type SampleResponse struct {
}
