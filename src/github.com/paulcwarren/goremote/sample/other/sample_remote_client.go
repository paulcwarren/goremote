// Remote clients would be generated by decorating the 'application' interface with a go generate statement; i.e.
//
// //go:generate goremote -o ../somedir/sample_client_remote.go . MyService
//
// type MyService interface {
// ...
package main

import (
	"fmt"
	
	"github.com/paulcwarren/goremote"
	"github.com/paulcwarren/goremote/transports"
	"github.com/paulcwarren/goremote/sample"
	
)

type remoteClient struct {
	Transport goremote.Transport
}

func NewRemoteClient(transport goremote.Transport) *remoteClient {
	return &remoteClient{
		Transport: transport,
	}
}

func (r *remoteClient) SayHello(helloRequest sample.HelloRequest) (sample.HelloReply, error) {

	helloResponse := sample.HelloReply{}

	err := r.Transport.Send("samplemethod", helloRequest, helloResponse)
	if err != nil {
		return sample.HelloReply{}, err
	}

	return helloResponse, nil
}

// and these would be typically be defined by the application
type SampleRequest struct {
}

type SampleResponse struct {
}

func main() {
	
	transport := transports.NewGrpcTransport("localhost:50051") 
	client := NewRemoteClient(transport)
	
	r, err := client.SayHello(sample.HelloRequest{Name: "world"})
	if err != nil {
		fmt.Printf("could not greet: %v", err)
	}
	fmt.Printf("Greeting: %s", r.Message)
}
